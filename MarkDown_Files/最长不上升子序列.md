# 一种寻找最长不上升子序列的算法
---
## 材料：
1. 数组original[N]存储原数列；
2. 数组temp[N]存储最长不上升子序列；
3. len为子序列长度；
4. STL库函数：upper_bound(_FwdIt _First ,  _FwdIt _Last , const _Ty& _Val)用于寻找数列中第一个大于x的数；
---

## 方法：
   利用数列的 “拓扑形” ，这个词是我发明的....因为找不到其他贴切的词来形容；
   是要在temp中构建一个不上升的数列，而且这个数列只要是维持非升序就可以，这种拓扑不变性我叫他 “拓扑形”；
我们将temp看作一个栈，只要元素x比栈顶元素小就可以直接入栈，维持栈内为非升序；如果元素x比栈顶元素大，则
也可以入栈，只不过这时要寻找栈内第一个大于x的元素，然后将该元素前面的那个元素替换为x，这样仍然维持栈内
非升序；
    有些同学会问，这样的话入栈的元素跟原数列里的顺序会不一样的，其实在排序的一段时期内会有这种现象，不过不会
造成影响，这就是temp内以“替换”的方式维持“非升序”排列的目的————替换后整个数列的拓扑序**在temp长度发生改变之前不变**，长度发生改变之时就代表着新发现的序列长度比上一个发现的序列要长，不过这个时候上一个序列里的元素已经全部替
换为新序列的元素了。

---

## sum：
“最长不上升子序列”是一类事物的数学本质，掌握了一类事物的数学本质就可以解决所有建立在其上的问题了，比如“导弹拦截问题”，下面是该问题的链接，
大家可顺便练手：[导弹拦截](https://www.luogu.com.cn/problem/P1020)

---
