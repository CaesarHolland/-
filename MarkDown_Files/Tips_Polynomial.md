
# 一元高次多项式的求解问题

## Preface

    一元四次一下的多项式的求解都可以找到根的计算公式，四次多项式的攻破给当时的数学家以极大的热情扑向一元五次多项式的求解；
    但是，从16世纪中叶到19世纪初，这300年间，诸如欧拉、拉格朗日这些数学家们都做过一些尝试但都没有成功，后来拉格朗日觉得
    这个东西是无解的吧！然后高斯也意识到了这个问题，然后blablabla······直到法国英雄Golois伽罗华的降临，他的天才促进了今
    天我们称之为抽象代数这门学科的蓬勃发展！！~~ 伽罗华的思想就是把 f(x)=0 的求解问题转化为确定对应的伽罗华群是否为所谓
    可解群的问题；
    可解群是群论中的一个重要内容，曾有一个著名的猜测叫Burnside猜测，
    说就奇数个元素的有限群是可解群。这个问题在1963年已被数学家Feit和
    Thompson解决，啊证明很长，有闲的同学可以看论文——《太平洋数学杂志1963年刊》；结论就是，不可解群有很多例如n>=5时就是不
    可解群···
    也就是说他真的是不可解的····
····但不代表我们弄不到近似解 , 今天我们主要通过牛顿法求一下近似解:

---

## 牛顿切线法(迭代法) 1

设定x* 是方程f(x)=0的根，选取x0作为x* 的近似值，过点(x0, f(x0))做曲线f(x)=0的切线L，L的方程y=f(x0)+f'(x0)(x-x0)，求出L与x轴焦点的横坐标x1=x0-f(x0)/f'(x0)，称x1为x*的一次近似值，然后设置x0=x1，重复上面的过程，反复迭代，就可以得到一个比较精确的近似值。

### Code

    这是一个开放的程序，你可以输入不同的迭代次数观察不同的f值的变化；
    代码部分见库——Newton_polynomial.cpp;

---

## 牛顿迭代法 2
该算法做了一定优化，与上面相比增加了许多判断以及筛查机制，并增加了误差范围显示【Error range】，但核心公式没有变化；
在初始化函数时我把误差限范围参数esp也设置成用户可自定义来观察其变化，建议值为1；
```cpp
    cin>>a>>b>>eps;
    double temp = Polynomial_Root(c,n,a,b,eps);
```
a和b为参数可能存在的范围，要保证参数在此范围内一定存在;
另外的内容代码中有详细注释，在此就不再叙述了;
### Code

    代码部分见库——Opt_ntPoly.cpp;

---

## GSL库，可以利用该数学函数库求解多项式

该库包含多项式求解器 **gsl_poly_complex_solve** ，可以一次性求出所有解，求解原理仍然是迭代法，但算法经过优化，提高精准度；具体文档部分可以在
[GCL_POLY](https://www.gnu.org/software/gsl/doc/html/poly.html#c.gsl_poly_complex_workspace)找到。

### Code

    代码部分见库——lib_Polynomial.cpp;

---

## 还有一种万能解题法——图灵法！

其实就是暴力破解··· 自计算机诞生之日起，我们用violence武力破解了多少个诸如黎曼猜想这种能用但用的不踏实的猜想···虽然现在用着还是不踏实，尽管我们已经验证了十万亿个零点了，但是数学就是这样，只有一种理论通过严谨的证明公式形成一个完美的闭环，才能成为定理，不然就算验证了10000000亿亿亿亿亿亿亿亿亿个非平凡零点都符合的超好也不配称为“定理”，尽管黎曼猜想已逐渐成为很多现代技术发展的基石，如果某一天突然出现一个不吻合的非平凡零点，那估计很多人会疯的吧。

---

## 另：一元高次多项式的加减乘运算
该程序将可以实现一元高次多项式的加法减法和乘法的运算，输入输出都是多项式的系数，当然，如有需要可以加入迭代判断参数来输出完整的多项式；

### Code:

    代码部分见库——Add_Poly.cpp;

---
