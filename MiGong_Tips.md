# 走迷宫系列

>问题：
>有一个n*m的移动迷宫，啊不是，静止的迷宫~
>0代表有路——1代表有怪兽——你需要计算出从起点到
>终点要走的步数(不一定最短)反正要出去
>
>输入：
>第一行：n , m
>然后输入n*m的迷宫

## 解法1：使用queue + pair：

#### 参数解读：
     g数组存储迷宫，d数组存储“走到这里走了多少步”，d的状态转移公式
     (这里用到了DP的概念，不过只是方便表达一下)是:
        **d[x][y] = d[x'][y'] + 1;**
     也就是：走到这一步所走的步数是走到上一个位置的步数加一；

     这里声明了一个pair，然后声明了一个pair型的queue，方便存储坐标x\y;  
     你可能还注意到有个奇怪的for循环参数 “auto &v” 是个神么，不要慌，最
     下面的【知识补充】里有简要解读;

#### 开始了：
     过程很简单：从起点开始走，在路口处看看四周哪有路，有路的方向记下到
     小本本上，待会儿一个个试，而且每试一个方向之前都得先在小本本上把这
     个方向划掉防止忘记了之后重走以至于掉进死循环（预防AD从我做起），如
     果在这个方向走到头没路了，这时，小本本上的没被划掉的地方开始的第一
     行就是你刚才遇到的岔路口的位置，你就可以安全返回啦~ 然后在岔路口重
     复动作，然后重复重复······什么时候本本空了，就该结束了！这个时候只
     有两种可能：
     
**一：你出去啦，完结撒花；**
**二：你没出去你死了，完结撒花；**

     好了概述完了我们看看如何实现：
     首先，小本本，由于要记录x和y，同时又想用到一种先进先出的结构，自然想到了queue，然后想到了pair，于是就有了queue<pair>q;
     技术细节见【知识补充】;

     走的过程中的上下左右方向我们定义在两个数组dx和dy里，这样以后在路口处可以通过循环很方便的遍历四个方向；

     初始化后直接进入迷宫，其他部分不赘述了，我猜有个地方很多人可能不是很明白，为什么每次取出一个坐标后总要将其从队里删除？

(''')
        auto t = q.front();
        q.pop();
(''')

     原因是这样：
     ![](one.png)  ![]("two.png") ![]("three.png")
     ![](https://github.com/CaesarHolland/Algorithm-one/blob/master/four.png) ![]("five.png") ![]("six.png")
     
     中间循环计算步数，利用上面得出的步数状态方程；
**
     得出结果，输出，**完结撒花~**
-----------
